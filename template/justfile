PYTHON_VERSION := `cat .python-version`

COMPOSE_DEV := "compose.dev.yml"
COMPOSE_PROD := "compose.prod.yml"

# Gracefully fallback if no tags exist
LATEST_VERSION_TAG := `git describe --tags --abbrev=0 --match "v*" 2>/dev/null | sed 's/^v//' || echo "0.0.0"`
VERSION := `dunamai from git 2>/dev/null || echo 0.0.0`

# List available commands
default:
    @just --list

[group('Helpers')]
install-deps:
    @uv tool install dunamai
    @uv tool install semver
    @uv tool install "python-dotenv[cli]"
    @uv tool install copier
    @uv tool install babel
    @uv tool install pre-commit

[group('Helpers')]
_check-clean:
    @git diff --quiet || (echo "❌ Uncommitted changes found. Commit or stash them before building." && exit 1)
    @git diff --cached --quiet || (echo "❌ Staged but uncommitted changes found. Commit them before building." && exit 1)

[group('Helpers')]
_check-unpushed-commits:
    @git fetch origin > /dev/null
    @commits=`git rev-list HEAD ^origin/HEAD --count`; \
    if [ "$commits" -ne 0 ]; then \
        echo "❌ You have local commits that haven't been pushed."; \
        exit 1; \
    fi

[group('Helpers')]
_check-last-commit-tagged:
    @if [ -z "$(git tag --points-at HEAD)" ]; then \
        echo "❌ Current commit is not tagged."; \
        echo "   Please checkout a clean tag before building production."; \
        exit 1; \
    fi

[group('Helpers')]
_update_local_deps:
    @pnpm i # Before building the first time, lockfiles will not exist
    @uv sync # Before building the first time, lockfiles will not exist

# Runs the dev environment with watch mode and cleans up orphans
[group('Local Development')]
dev: _update_local_deps
    ENVIRONMENT=development \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_BAKE=true \
    docker compose -f {{COMPOSE_DEV}} up --watch --remove-orphans

# Runs the dev environment locally without Docker
[group('Local Development')]
local-dev: _update_local_deps
    @dotenv -f .env.local run -- ./start.sh local-dev

# Builds the dev image with COMPOSE_BAKE set
[group('CI/CD')]
build-dev: _update_local_deps
    ENVIRONMENT=development \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_BAKE=true \
    docker compose -f {{COMPOSE_DEV}} build

# Builds a test production image with COMPOSE_BAKE set
[group('CI/CD')]
test-build-prod: _update_local_deps
    ENVIRONMENT=production \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_BAKE=true \
    docker compose -f {{COMPOSE_PROD}} build


# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
release: _check-clean _check-unpushed-commits _check-last-commit-tagged _update_local_deps
    ENVIRONMENT=production \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    VERSION={{VERSION}} \
    docker buildx bake -f {{COMPOSE_PROD}} --push

# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
deploy-latest HOST: release
    DOCKER_HOST="ssh://{{ HOST }}" docker compose -f {{COMPOSE_PROD}} up -d --remove-orphans --pull always

# Bump major version based on the latest tag
[group('versioning')]
bump-major:
    @just _semver_bump major

# Bump minor version based on the latest tag
[group('versioning')]
bump-minor:
    @just _semver_bump minor

# Bump patch version based on the latest tag
[group('versioning')]
bump-patch:
    @just _semver_bump patch

# Internal recipe to bump version and create git tag
[group('versioning')]
_semver_bump type: _check-clean _check-unpushed-commits
    #!/usr/bin/env bash
    if ! git tag | grep -q '^v'; then
        echo "No version tags found. Creating initial tag v0.0.1..."
        git tag -a "v0.0.1" -m "Initial version"
        echo "Created git tag: v0.0.1"
        echo "To push the tag, run: git push origin v0.0.1"
        exit 0
    fi

    NEW_VERSION=$(pysemver bump {{type}} {{LATEST_VERSION_TAG}})
    if [ -z "$NEW_VERSION" ]; then
        echo "❌ Failed to compute new version. Aborting to avoid invalid tag."
        exit 1
    fi

    echo "New version: $NEW_VERSION"

    TAG="v${NEW_VERSION}"

    if git rev-parse "$TAG" >/dev/null 2>&1; then
        echo "Tag $TAG already exists. Skipping tag creation."
    else
        echo "Creating git tag $TAG..."
        git tag -a "$TAG" -m "Version $NEW_VERSION"
        echo "Created git tag: $TAG"
        echo "To push the tag, run: git push origin $TAG"
    fi

# Starts a new branch for development
[group('gitflow')]
start-branch BRANCH: _check-clean _check-unpushed-commits
    git checkout main
    git pull origin main
    git checkout -b {{BRANCH}}

# Adds and commits all changes with a message
[group('gitflow')]
commit MESSAGE:
    git add .
    git commit -m "{{MESSAGE}}"

# Pushes all tags to the remote repository
[group('gitflow')]
push-tags:
    git push --tags

# Create PR for current branch
[group('gitflow')]
pr:
    @git push

    @branch=$(git rev-parse --abbrev-ref HEAD) && \
    gh pr create \
      --base main \
      --title "$branch" \
      --body "$(git log origin/main..HEAD --pretty=format:'- %s')"


# Merge PR using squash
[group('gitflow')]
merge:
    gh pr merge --squash --delete-branch


# Extracts translations from source files
[group('localization')]
extract-translations:
    @pybabel extract -F babel.cfg -o locales/messages.pot ./src

# Creates a new language file for localization
[group('localization')]
new-locale LANG:
    @pybabel init -i locales/messages.pot -d locales -l {{LANG}}

# Updates existing language files for localization
[group('localization')]
update-locale-files:
    @pybabel update -i locales/messages.pot -d locales

# Compiles the language files into binary format
[group('localization')]
compile-locales:
    @pybabel compile -d locales


# Dump untranslated strings per language to a given DEST directory
[group('localization')]
dump-untranslated DEST:
    #!/usr/bin/env bash

    mkdir -p {{DEST}}

    for LANG_DIR in locales/??; do
        LANG=$(basename ${LANG_DIR} | cut -d/ -f1)
        msgattrib --untranslated ./locales/${LANG}/LC_MESSAGES/messages.po > "{{DEST}}/untranslated_${LANG}.po"
    done

# Update to the latest version of the project scaffolding
[group('scaffolding')]
update-scaffolding:
    @echo "Updating project scaffolding..."
    @copier update -A --trust
    @pnpm i
    @uv sync
    @echo "Project scaffolding updated."
    @echo "Please review the changes and commit."

# Initialize git repo
[group('initialization')]
git-init PROJECT: _update_local_deps
    @[ -d .git ] || (git init && git add . && SKIP=no-commit-to-branch git commit -m "initial commit for {{ PROJECT }}" && git tag -a "v0.0.1" -m "Initial version")

[group('initialization')]
create-github-repo REPO:
    @gh repo create {{ REPO }} --private -s . --push

# Trust mise
[group('initialization')]
mise-trust:
    @mise trust

# Untrust mise
[group('initialization')]
mise-untrust:
    @mise trust --untrust

# Add DNS record
[group('initialization')]
add-dns-record RECORD:
    @scaffolding/cf.py add-dns-record {{ RECORD }}
