PYTHON_VERSION := `cat .python-version`

COMPOSE_DEV := "compose.dev.yml"
COMPOSE_PROD := "compose.prod.yml"

# Gracefully fallback if no tags exist
LATEST_VERSION_TAG := `git describe --tags --abbrev=0 --match "v*" 2>/dev/null | sed 's/^v//' || echo "0.0.0"`
VERSION := `uvx dunamai from git 2>/dev/null || echo 0.0.0`

# List available commands
default:
    @just --list

[group('Helpers')]
_check-clean:
    @git diff --quiet || (echo "❌ Uncommitted changes found. Commit or stash them before building." && exit 1)
    @git diff --cached --quiet || (echo "❌ Staged but uncommitted changes found. Commit them before building." && exit 1)

[group('Helpers')]
_check-unpushed-commits:
    @git fetch origin > /dev/null
    @commits=`git rev-list HEAD ^origin/HEAD --count`; \
    if [ "$commits" -ne 0 ]; then \
        echo "❌ You have local commits that haven't been pushed."; \
        exit 1; \
    fi

[group('Helpers')]
_check-last-commit-tagged:
    @if [ -z "$(git tag --points-at HEAD)" ]; then \
        echo "❌ Current commit is not tagged."; \
        echo "   Please checkout a clean tag before building production."; \
        exit 1; \
    fi

# Runs the dev environment with watch mode and cleans up orphans
[group('Local Development')]
dev:
    ENVIRONMENT=development \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_BAKE=true \
    docker compose -f {{COMPOSE_DEV}} up --watch --remove-orphans

# Builds the dev image with COMPOSE_BAKE set
[group('CI/CD')]
build-dev:
    ENVIRONMENT=development \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_BAKE=true \
    docker compose -f {{COMPOSE_DEV}} build


# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
release: _check-clean _check-unpushed-commits _check-last-commit-tagged
    ENVIRONMENT=production \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    VERSION={{VERSION}} \
    docker buildx bake -f {{COMPOSE_PROD}} --push


# Bump major version based on the latest tag
[group('versioning')]
bump-major:
    @just _semver_bump major

# Bump minor version based on the latest tag
[group('versioning')]
bump-minor:
    @just _semver_bump minor

# Bump patch version based on the latest tag
[group('versioning')]
bump-patch:
    @just _semver_bump patch

# Internal recipe to bump version and create git tag
[group('versioning')]
_semver_bump type: _check-clean _check-unpushed-commits
    #!/usr/bin/env bash
    if ! git tag | grep -q '^v'; then
        echo "No version tags found. Creating initial tag v0.0.1..."
        git tag -a "v0.0.1" -m "Initial version"
        echo "Created git tag: v0.0.1"
        echo "To push the tag, run: git push origin v0.0.1"
        exit 0
    fi

    NEW_VERSION=$(uvx --from semver pysemver bump {{type}} {{LATEST_VERSION_TAG}})
    if [ -z "$NEW_VERSION" ]; then
        echo "❌ Failed to compute new version. Aborting to avoid invalid tag."
        exit 1
    fi

    echo "New version: $NEW_VERSION"

    TAG="v${NEW_VERSION}"

    if git rev-parse "$TAG" >/dev/null 2>&1; then
        echo "Tag $TAG already exists. Skipping tag creation."
    else
        echo "Creating git tag $TAG..."
        git tag -a "$TAG" -m "Version $NEW_VERSION"
        echo "Created git tag: $TAG"
        echo "To push the tag, run: git push origin $TAG"
    fi

# Starts a new branch for development
[group('gitflow')]
start-branch BRANCH: _check-clean _check-unpushed-commits
    git checkout main
    git pull origin main
    git checkout -b {{BRANCH}}

# Adds and commits all changes with a message
[group('gitflow')]
commit MESSAGE:
    git add .
    git commit -m "{{MESSAGE}}"

# Create PR for current branch
[group('gitflow')]
pr:
    @git push

    @branch=$(git rev-parse --abbrev-ref HEAD) && \
    gh pr create \
      --base main \
      --title "$branch" \
      --body "$(git log origin/main..HEAD --pretty=format:'- %s')"


# Merge PR using squash
[group('gitflow')]
merge:
    gh pr merge --squash --delete-branch


# Extracts translations from source files
[group('localization')]
extract-translations:
    @uv run pybabel extract -F babel.cfg -o locales/messages.pot ./src

# Creates a new language file for localization
[group('localization')]
new-locale LANG:
    @uv run pybabel init -i locales/messages.pot -d locales -l {{LANG}}

# Updates existing language files for localization
[group('localization')]
update-locale-files:
    @uv run pybabel update -i locales/messages.pot -d locales

# Compiles the language files into binary format
[group('localization')]
compile-locales:
    @uv run pybabel compile -d locales


# Dump untranslated strings per language to a given DEST directory
[group('localization')]
dump-untranslated DEST:
    #!/usr/bin/env bash

    mkdir -p {{DEST}}

    for LANG_DIR in locales/??; do
        LANG=$(basename ${LANG_DIR} | cut -d/ -f1)
        msgattrib --untranslated ./locales/${LANG}/LC_MESSAGES/messages.po > "{{DEST}}/untranslated_${LANG}.po"
    done

# Update to the latest version of the project scaffolding
[group('scaffolding')]
update-scaffolding:
    @echo "Updating project scaffolding..."
    @uvx copier update -A --trust
    @echo "Project scaffolding updated."
    @echo "Please review the changes and commit."
