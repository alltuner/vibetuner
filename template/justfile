# Gracefully fallback if no tags exist
LATEST_VERSION_TAG := `git describe --tags --abbrev=0 --match "v*" 2>/dev/null | sed 's/^v//' || echo "0.0.0"`
VERSION := `dunamai from git 2>/dev/null || echo 0.0.0`

PROJECT_SLUG := `uv run python -c "import yaml; print(yaml.safe_load(open('.copier-answers.yml'))['project_slug'].strip())"`
FQDN := `uv run python -c "import yaml; print(yaml.safe_load(open('.copier-answers.yml')).get('fqdn', '').strip())"`
PYTHON_VERSION := `tr -d '\n\r' < .python-version`

# List available commands
default:
    @just --list

[group('Helpers')]
_check-clean:
    @git diff --quiet || (echo "âŒ Uncommitted changes found. Commit or stash them before building." && exit 1)
    @git diff --cached --quiet || (echo "âŒ Staged but uncommitted changes found. Commit them before building." && exit 1)

[group('Helpers')]
_check-unpushed-commits:
    @git fetch origin > /dev/null
    @commits=`git rev-list HEAD ^origin/HEAD --count`; \
    if [ "$commits" -ne 0 ]; then \
        echo "âŒ You have local commits that haven't been pushed."; \
        exit 1; \
    fi

[group('Helpers')]
_check-last-commit-tagged:
    @if [ -z "$(git tag --points-at HEAD)" ]; then \
        echo "âŒ Current commit is not tagged."; \
        echo "   Please checkout a clean tag before building production."; \
        exit 1; \
    fi

[group('Helpers')]
_update_local_deps:
    @bun install # Before building the first time, lockfiles will not exist
    @uv sync --all-extras # Before building the first time, lockfiles will not exist

# Runs the dev environment with watch mode and cleans up orphans
[group('Local Development')]
dev: _update_local_deps
    ENVIRONMENT=development \
    COMPOSE_BAKE=true \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    docker compose -f compose.dev.yml up --watch --remove-orphans

# Runs the dev environment locally without Docker
[group('Local Development')]
local-dev PORT="8000": _update_local_deps
    @atl run dev --port {{PORT}}

# Runs the task worker locally without Docker
[group('Local Development')]
worker-dev: _update_local_deps
    @atl run dev worker

# Sync deps
[group('Local Development')]
sync: _update_local_deps
    @echo "Sync deps with project..."
    @uv sync --all-extras
    @bun install

# Builds the dev image with COMPOSE_BAKE set
[group('CI/CD')]
build-dev: _update_local_deps
    ENVIRONMENT=development \
    COMPOSE_BAKE=true \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    docker compose --progress=plain -f compose.dev.yml build

# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
test-build-prod: _update_local_deps
    ENVIRONMENT=production \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    FQDN={{FQDN}} \
    docker buildx bake -f compose.prod.yml

# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
build-prod: _check-clean _check-last-commit-tagged _update_local_deps
    ENVIRONMENT=production \
    VERSION={{VERSION}} \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    FQDN={{FQDN}} \
    docker buildx bake -f compose.prod.yml


# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
release: _check-clean _check-last-commit-tagged _update_local_deps
    ENVIRONMENT=production \
    VERSION={{VERSION}} \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    FQDN={{FQDN}} \
    docker buildx bake -f compose.prod.yml --push

# Builds the prod image with COMPOSE_BAKE set (only if on a clean, tagged commit)
[group('CI/CD')]
deploy-latest HOST: release
    DOCKER_HOST="ssh://{{ HOST }}" \
    PYTHON_VERSION={{PYTHON_VERSION}} \
    COMPOSE_PROJECT_NAME={{PROJECT_SLUG}} \
    FQDN={{FQDN}} \
    docker compose -f compose.prod.yml up -d --remove-orphans --pull always

# Bump major version based on the latest tag
[group('versioning')]
bump-major:
    @just _semver_bump major

# Bump minor version based on the latest tag
[group('versioning')]
bump-minor:
    @just _semver_bump minor

# Bump patch version based on the latest tag
[group('versioning')]
bump-patch:
    @just _semver_bump patch

# Internal recipe to bump version and create git tag
[group('versioning')]
_semver_bump type: _check-clean
    #!/usr/bin/env bash
    if ! git tag | grep -q '^v'; then
        echo "No version tags found. Creating initial tag v0.0.1..."
        git tag -a "v0.0.1" -m "Initial version"
        echo "Created git tag: v0.0.1"
        echo "To push the tag, run: git push origin v0.0.1"
        exit 0
    fi

    NEW_VERSION=$(pysemver bump {{type}} {{LATEST_VERSION_TAG}})
    if [ -z "$NEW_VERSION" ]; then
        echo "âŒ Failed to compute new version. Aborting to avoid invalid tag."
        exit 1
    fi

    echo "New version: $NEW_VERSION"

    TAG="v${NEW_VERSION}"

    if git rev-parse "$TAG" >/dev/null 2>&1; then
        echo "Tag $TAG already exists. Skipping tag creation."
    else
        echo "Creating git tag $TAG..."
        git tag -a "$TAG" -m "Version $NEW_VERSION"
        echo "Created git tag: $TAG"
        echo "To push the tag, run: git push origin $TAG"
    fi

# Starts a new branch for development
[group('gitflow')]
start-branch BRANCH: _check-clean _check-unpushed-commits
    git checkout main
    git pull origin main
    git checkout -b {{BRANCH}}

# Adds and commits all changes with a message
[group('gitflow')]
commit MESSAGE:
    git add .
    git commit -m "{{MESSAGE}}"

# Pushes all tags to the remote repository
[group('gitflow')]
push-tags:
    git push --tags

# Create PR for current branch
[group('gitflow')]
pr:
    @git push

    @branch=$(git rev-parse --abbrev-ref HEAD) && \
    gh pr create \
      --base main \
      --title "$branch" \
      --body "$(git log origin/main..HEAD --pretty=format:'- %s')"


# Merge PR using squash
[group('gitflow')]
merge:
    gh pr merge --squash --delete-branch

# Lint markdown files including dot directories
[group('linting')]
lint-md:
    uv run rumdl check . .claude .github .vscode

# Lint Python files with ruff
[group('linting')]
lint-py:
    uv run ruff check .

# Type check Python files with ty
[group('linting')]
type-check:
    uv run ty check .

# Lint Jinja templates with djlint (check only)
[group('linting')]
lint-jinja:
    uv run djlint templates/ --check

# Lint TOML files with taplo (check only)
[group('linting')]
lint-toml:
    uv run taplo fmt --check

# Run all linting checks
[group('linting')]
lint: lint-md lint-py type-check lint-jinja lint-toml

# Format Python files with ruff
[group('formatting')]
format-py:
    uv run ruff format .

# Format Jinja templates with djlint
[group('formatting')]
format-jinja:
    uv run djlint templates/ --reformat

# Format TOML files with taplo
[group('formatting')]
format-toml:
    uv run taplo fmt

# Format all code
[group('formatting')]
format: format-py format-jinja format-toml

# Complete i18n workflow: extract, update, and compile translations
[group('localization')]
i18n: extract-translations update-locale-files compile-locales
    @echo "âœ“ Complete i18n workflow finished"

# Generate or update README.md using Claude Code
[group('documentation')]
readme:
    @echo "ðŸ“ Generating README.md..."
    @claude /readme
    @echo "âœ“ README.md generated/updated"

# Extracts translations from source files
[group('localization')]
extract-translations:
    @uv run pybabel extract -F babel.cfg -o locales/messages.pot .

# Creates a new language file for localization
[group('localization')]
new-locale LANG:
    @uv run pybabel init -i locales/messages.pot -d locales -l {{LANG}}

# Updates existing language files for localization
[group('localization')]
update-locale-files:
    @find locales -type f -path "*/LC_MESSAGES/messages.po" -exec sh -c 'echo " â†º {}"; msguniq "{}" -o "{}"; msgmerge --update --backup=none --previous "{}" locales/messages.pot' \;

# Compiles the language files into binary format
[group('localization')]
compile-locales:
    @uv run pybabel compile -d locales

# Dump untranslated strings per language to a given DEST directory
[group('localization')]
dump-untranslated DEST:
    #!/usr/bin/env bash

    mkdir -p {{DEST}}

    for LANG_DIR in locales/??; do
        LANG=$(basename ${LANG_DIR} | cut -d/ -f1)
        msgattrib --untranslated ./locales/${LANG}/LC_MESSAGES/messages.po > "{{DEST}}/untranslated_${LANG}.po"
    done

# Update to the latest version of the project scaffolding
[group('scaffolding')]
update-scaffolding:
    @echo "Updating project scaffolding..."
    @copier update -A --trust
    @bun install
    @uv sync --all-extras
    @echo "Project scaffolding updated."
    @echo "Please review the changes and commit."

# Initialize git repo
[group('initialization')]
git-init PROJECT: _update_local_deps
    @[ -d .git ] || (git init && git add . && SKIP=no-commit-to-branch git commit -m "initial commit for {{ PROJECT }}" && git tag -a "v0.0.1" -m "Initial version")

[group('initialization')]
create-github-repo REPO:
    @gh repo create {{ REPO }} --private -s . --push
